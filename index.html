<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Solitaire Pro</title>
    <style>
        :root {
            --card-width: 12.5vw; /* Responsive width */
            --card-height: 17.5vw;
            --card-gap: 1.5vw;
            --bg-color: #2e7d32;
            --card-back: repeating-linear-gradient(
                45deg,
                #606dbc,
                #606dbc 10px,
                #465298 10px,
                #465298 20px
            );
        }

        @media (min-width: 600px) {
            :root {
                --card-width: 80px;
                --card-height: 112px;
                --card-gap: 15px;
            }
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            user-select: none;
            overflow-x: hidden;
            touch-action: pan-y;
        }

        header {
            width: 100%;
            padding: 10px 15px;
            background: rgba(0,0,0,0.25);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            position: sticky;
            top: 0;
            z-index: 200;
            backdrop-filter: blur(5px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .header-left { display: flex; align-items: center; gap: 15px; }
        .header-right { display: flex; align-items: center; gap: 8px; }

        h1 { margin: 0; font-size: 1.1rem; display: block; }
        #score { font-weight: bold; font-family: monospace; font-size: 1.1rem; }
        
        button {
            padding: 8px 12px;
            background: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 700;
            color: var(--bg-color);
            font-size: 0.85rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: transform 0.1s, opacity 0.2s;
        }
        
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Silver Solve Button */
        button.solve-btn {
            background: linear-gradient(to bottom, #ffffff, #e0e0e0);
            color: #333;
            border: 1px solid #999;
        }

        #game-board {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(7, var(--card-width));
            gap: var(--card-gap);
            padding: 10px;
            padding-bottom: 80px;
            justify-content: center;
        }

        /* --- LAYOUT FIX: Enforce Top Row Height & Spacing --- */
        .top-row {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(7, var(--card-width));
            gap: var(--card-gap);
            /* Vital: Add bottom margin to separate from Tableau */
            margin-bottom: 30px; 
            height: var(--card-height);
        }

        .stock-pile, .discard-pile, .foundation {
            width: var(--card-width);
            height: var(--card-height);
            border: 2px solid rgba(255,255,255,0.25);
            border-radius: 6px;
            position: relative;
            box-sizing: border-box;
        }

        .foundation { 
            background: rgba(0,0,0,0.15); 
            text-align: center;
            line-height: var(--card-height);
            font-size: 2.5rem; 
            color: rgba(255,255,255,0.15);
        }

        /* Card Styles */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            border-radius: 6px;
            box-shadow: 1px 1px 4px rgba(0,0,0,0.3);
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: grab;
            transition: top 0.1s;
            box-sizing: border-box;
            touch-action: none;
            overflow: hidden;
        }

        .card.red { color: #d32f2f; }
        .card.black { color: #212121; }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Clean Card Face */
        .card-corner {
            position: absolute;
            top: 4px;
            left: 4px;
            font-size: 1.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 0.9;
            font-weight: 800;
        }
        
        .card-center { 
            position: absolute;
            top: 55%; /* Slight push down to center better */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem; 
            line-height: 1;
        }

        .card.back {
            background: var(--card-back);
            border: 2px solid #fff;
        }
        .card.back .card-inner { display: none; }

        .tableau-col {
            position: relative;
            width: var(--card-width);
            min-height: var(--card-height);
            /* Hit area for dropping */
            padding-bottom: 50px; 
        }

        @media (max-width: 600px) {
            h1 { display: none; } 
            header { padding: 8px; }
            .header-left { gap: 8px; }
            .header-right { gap: 4px; }
            button { padding: 6px 8px; font-size: 0.8rem; }
            .card-center { font-size: 2.2rem; } 
            .card-corner { font-size: 0.9rem; top: 2px; left: 2px; }
        }
        
        .card.dragging {
            z-index: 9999 !important;
            opacity: 0.95;
            pointer-events: none;
            box-shadow: 5px 10px 20px rgba(0,0,0,0.5);
            transform: scale(1.05); 
        }
        .placeholder { opacity: 0.3; }

        #win-message {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: white; color: black;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,0.7);
            z-index: 10000;
            min-width: 200px;
        }
    </style>
</head>
<body>

<header>
    <div class="header-left">
        <h1>Solitaire</h1>
        <span id="score">Score: 0</span>
    </div>
    <div class="header-right">
        <button id="undo-btn" onclick="undo()">Undo</button>
        <button id="restart-btn" onclick="restartLevel()">Restart</button>
        <button id="solve-btn" class="solve-btn" onclick="startSmartSolve()">Auto</button>
        <button id="new-btn" onclick="newGame()">New</button>
    </div>
</header>

<div id="game-board">
    <div class="top-row">
        <div id="stock" class="stock-pile" onclick="drawCard()"></div>
        <div id="discard" class="discard-pile"></div>
        <div style="visibility: hidden;"></div>
        <div id="foundation-0" class="foundation" data-target="foundation" data-index="0">♥</div>
        <div id="foundation-1" class="foundation" data-target="foundation" data-index="1">♦</div>
        <div id="foundation-2" class="foundation" data-target="foundation" data-index="2">♣</div>
        <div id="foundation-3" class="foundation" data-target="foundation" data-index="3">♠</div>
    </div>

    <div id="tableau-0" class="tableau-col" data-target="tableau" data-index="0"></div>
    <div id="tableau-1" class="tableau-col" data-target="tableau" data-index="1"></div>
    <div id="tableau-2" class="tableau-col" data-target="tableau" data-index="2"></div>
    <div id="tableau-3" class="tableau-col" data-target="tableau" data-index="3"></div>
    <div id="tableau-4" class="tableau-col" data-target="tableau" data-index="4"></div>
    <div id="tableau-5" class="tableau-col" data-target="tableau" data-index="5"></div>
    <div id="tableau-6" class="tableau-col" data-target="tableau" data-index="6"></div>
</div>

<div id="win-message">
    <h2>You Win!</h2>
    <p>All cards collected!</p>
    <br>
    <button onclick="newGame()">Play Again</button>
</div>

<script>
    const suits = ['h', 'd', 'c', 's'];
    const symbols = {'h': '♥', 'd': '♦', 'c': '♣', 's': '♠'};
    const colors = {'h': 'red', 'd': 'red', 'c': 'black', 's': 'black'};
    const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
    
    let deck = [], stock = [], discard = [], tableau = [], foundations = [];
    let initialDeckState = [];
    let score = 0;
    let historyStack = [];
    let isSolving = false; 

    // Safety: Prevent accidental navigation
    window.addEventListener('beforeunload', function (e) {
        e.preventDefault(); 
        e.returnValue = '';
    });

    history.pushState(null, document.title, location.href);
    window.addEventListener('popstate', function (event) {
        if (confirm("Go back? You will lose this game state.")) {
            history.back();
        } else {
            history.pushState(null, document.title, location.href);
        }
    });

    function createDeck() {
        let newDeck = [];
        for (let s of suits) {
            for (let i = 0; i < values.length; i++) {
                newDeck.push({ 
                    suit: s, value: values[i], rank: i + 1, faceUp: false,
                    id: s + (i+1)
                });
            }
        }
        return newDeck;
    }

    function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
    }

    function newGame() {
        if(score > 0 && !confirm("Start a brand new game?")) return;
        let d = createDeck();
        shuffle(d);
        initialDeckState = JSON.parse(JSON.stringify(d));
        startGame(d);
    }

    function restartLevel() {
        if(!confirm("Restart this exact deal?")) return;
        let d = JSON.parse(JSON.stringify(initialDeckState));
        startGame(d);
    }

    function startGame(gameDeck) {
        isSolving = false;
        enableControls(true);
        score = 0;
        historyStack = []; 
        updateScore(0);
        document.getElementById('win-message').style.display = 'none';

        tableau = [[], [], [], [], [], [], []];
        foundations = [[], [], [], []];
        discard = [];
        stock = [];

        for (let i = 0; i < 7; i++) {
            for (let j = 0; j <= i; j++) {
                let card = gameDeck.pop();
                card.faceUp = (j === i); 
                tableau[i].push(card);
            }
        }
        stock = gameDeck; 
        render();
    }

    // --- SMART SOLVER LOGIC ---
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    
    // Track recent moves to prevent infinite loops (e.g. King left <-> King right)
    let botMoveHistory = [];

    async function startSmartSolve() {
        if (isSolving) return;
        if (!confirm("Let the bot take over?")) return;
        
        isSolving = true;
        enableControls(false);
        saveState(); 
        botMoveHistory = []; // Reset loop detector

        let consecutiveNonMoves = 0;
        // Limit total moves to prevent infinite running
        let maxMoves = 300; 

        while (isSolving && consecutiveNonMoves < 12 && maxMoves > 0) {
            let moved = await performBestMove();
            if (moved) {
                consecutiveNonMoves = 0;
                render();
                await sleep(150); 
                maxMoves--;
            } else {
                consecutiveNonMoves++;
                // If stuck, try drawing
                drawCard(true); 
                render();
                await sleep(100);
            }
            if (foundations.every(f => f.length === 13)) {
                checkWin();
                break;
            }
        }
        
        if (!foundations.every(f => f.length === 13)) {
             isSolving = false;
             enableControls(true);
             alert("Bot stuck. Try moving a card yourself!");
        }
    }

    async function performBestMove() {
        // Priority 1: Move to Foundation (Always good)
        if (await tryMoveToFoundation()) return true;

        // Priority 2: Uncover face-down cards (The goal of the game)
        if (await tryTableauMove({ onlyIfReveals: true })) return true;

        // Priority 3: Organize piles (Move visible stacks to valid spots to allow future moves)
        if (await tryTableauMove({ onlyIfReveals: false })) return true;

        // Priority 4: Bring card DOWN from Foundation (To unstick the game)
        if (await tryFoundationToTableau()) return true;
        
        return false;
    }

    // --- MOVE LOGIC ---

    async function tryMoveToFoundation() {
        // Check Tableau
        for (let i = 0; i < 7; i++) {
            if (tableau[i].length === 0) continue;
            let card = tableau[i][tableau[i].length - 1];
            let fIdx = suits.indexOf(card.suit);
            if (foundations[fIdx].length === card.rank - 1) {
                foundations[fIdx].push(tableau[i].pop());
                if(tableau[i].length > 0) tableau[i][tableau[i].length-1].faceUp = true;
                updateScore(10);
                return true;
            }
        }
        // Check Discard
        if (discard.length > 0) {
            let card = discard[discard.length - 1];
            let fIdx = suits.indexOf(card.suit);
            if (foundations[fIdx].length === card.rank - 1) {
                foundations[fIdx].push(discard.pop());
                updateScore(10);
                return true;
            }
        }
        return false;
    }

    async function tryTableauMove({ onlyIfReveals }) {
        // Try moving any valid stack from col A to col B
        for (let srcIdx = 0; srcIdx < 7; srcIdx++) {
            let col = tableau[srcIdx];
            if (col.length === 0) continue;

            // Find valid substacks (face up cards)
            let firstFaceUp = col.findIndex(c => c.faceUp);
            if (firstFaceUp === -1) continue;

            // Loop through all possible substacks in this column
            for (let splitIdx = firstFaceUp; splitIdx < col.length; splitIdx++) {
                let cardToMove = col[splitIdx];
                let isBaseOfPile = (splitIdx === firstFaceUp);

                // Optimization: Don't move a King from an empty spot to another empty spot
                if (cardToMove.rank === 13 && firstFaceUp === 0 && splitIdx === 0) {
                     // Moving a King that is already at the bottom of a pile
                     // Only useful if we are moving it to a DIFFERENT empty column? No, that's useless loop.
                     continue; 
                }

                // If "onlyIfReveals" is true, we skip if this doesn't expose a face-down card
                if (onlyIfReveals && firstFaceUp === 0) continue; 

                // Find a target
                let targetIdx = findTableauTarget(cardToMove, srcIdx);
                if (targetIdx !== -1) {
                    // Loop Prevention: Don't repeat recent moves
                    let moveSig = `${srcIdx}-${splitIdx}-${targetIdx}`;
                    if (botMoveHistory.includes(moveSig)) continue;

                    // Execute
                    let movingStack = col.splice(splitIdx);
                    tableau[targetIdx].push(...movingStack);
                    if (col.length > 0) col[col.length-1].faceUp = true;
                    
                    botMoveHistory.push(moveSig);
                    if (botMoveHistory.length > 10) botMoveHistory.shift();

                    return true;
                }
            }
        }
        return false;
    }

    async function tryFoundationToTableau() {
        // Try to pull a card BACK DOWN from foundation if it helps
        for (let fIdx = 0; fIdx < 4; fIdx++) {
            if (foundations[fIdx].length === 0) continue;
            
            let card = foundations[fIdx][foundations[fIdx].length - 1];
            
            // Can this card go onto any tableau column?
            // Note: We can only put it on a valid parent
            let targetIdx = findTableauTarget(card, -1); // -1 source means external
            
            if (targetIdx !== -1) {
                // Heuristic: Only move down if it's "useful". 
                // Simple check: Don't move down if it just goes to an empty column (wastes space usually).
                // Move down if it goes onto a card.
                if (tableau[targetIdx].length > 0) {
                    foundations[fIdx].pop();
                    tableau[targetIdx].push(card);
                    updateScore(-10); // Penalty for taking back, but allowed
                    return true;
                }
            }
        }
        return false;
    }

    function findTableauTarget(cardToPlace, ignoreColIdx) {
        for (let i = 0; i < 7; i++) {
            if (i === ignoreColIdx) continue;
            
            let col = tableau[i];
            // Empty Column -> Accepts King
            if (col.length === 0) {
                if (cardToPlace.rank === 13) return i;
            } else {
                // Occupied -> Check Color/Rank
                let topCard = col[col.length - 1];
                let isRed = (cardToPlace.suit === 'h' || cardToPlace.suit === 'd');
                let topIsRed = (topCard.suit === 'h' || topCard.suit === 'd');
                
                if (isRed !== topIsRed && topCard.rank === cardToPlace.rank + 1) {
                    return i;
                }
            }
        }
        return -1;
    }

    // --- STANDARD RENDER ---
    function enableControls(enabled) {
        document.getElementById('undo-btn').disabled = !enabled;
        document.getElementById('solve-btn').disabled = !enabled;
        document.getElementById('new-btn').disabled = !enabled;
        document.getElementById('restart-btn').disabled = !enabled;
    }

    function saveState() {
        if(isSolving) return;
        const state = {
            stock: JSON.parse(JSON.stringify(stock)),
            discard: JSON.parse(JSON.stringify(discard)),
            tableau: JSON.parse(JSON.stringify(tableau)),
            foundations: JSON.parse(JSON.stringify(foundations)),
            score: score
        };
        historyStack.push(state);
        if (historyStack.length > 50) historyStack.shift();
    }

    function undo() {
        if (isSolving) return;
        if (historyStack.length === 0) return;
        const prevState = historyStack.pop();
        stock = prevState.stock;
        discard = prevState.discard;
        tableau = prevState.tableau;
        foundations = prevState.foundations;
        score = prevState.score;
        updateScore(0);
        render();
    }

    function render() {
        const stockEl = document.getElementById('stock');
        stockEl.innerHTML = stock.length > 0 ? '<div class="card back"></div>' : '<span style="font-size:20px; color:rgba(255,255,255,0.3)">↻</span>';

        const discardEl = document.getElementById('discard');
        discardEl.innerHTML = '';
        if (discard.length > 0) {
            const topCard = discard[discard.length - 1];
            topCard.faceUp = true;
            const el = createCardElement(topCard, 'discard', 0, discard.length-1);
            discardEl.appendChild(el);
        }

        for (let i = 0; i < 4; i++) {
            const fEl = document.getElementById(`foundation-${i}`);
            fEl.innerHTML = symbols[suits[i]];
            if (foundations[i].length > 0) {
                const topCard = foundations[i][foundations[i].length - 1];
                const el = createCardElement(topCard, 'foundation', i, foundations[i].length - 1);
                fEl.appendChild(el);
            }
        }

        for (let i = 0; i < 7; i++) {
            const tEl = document.getElementById(`tableau-${i}`);
            tEl.innerHTML = '';
            tableau[i].forEach((card, idx) => {
                if (!card.faceUp && idx === tableau[i].length - 1) card.faceUp = true;
                const el = createCardElement(card, 'tableau', i, idx);
                // Vertical cascade
                el.style.top = `${idx * (window.innerWidth < 600 ? 25 : 30)}px`;
                tEl.appendChild(el);
            });
        }
        
        if (!isSolving) checkWin();
    }

    function createCardElement(card, source, colIdx, cardIdx) {
        const el = document.createElement('div');
        el.className = `card ${card.faceUp ? '' : 'back'} ${card.faceUp ? colors[card.suit] : ''}`;
        el.dataset.rank = card.rank;
        el.dataset.suit = card.suit;
        el.dataset.source = source;
        el.dataset.col = colIdx;
        el.dataset.idx = cardIdx;

        if (card.faceUp) {
            el.innerHTML = `
                <div class="card-inner">
                    <div class="card-corner">
                        <span>${card.value}</span>
                        <span>${symbols[card.suit]}</span>
                    </div>
                    <div class="card-center">${symbols[card.suit]}</div>
                </div>
            `;
            if (!isSolving) attachDragListeners(el);
        }
        return el;
    }

    function drawCard(suppressHistory = false) {
        if (isSolving && !suppressHistory) return; 
        if (!suppressHistory) saveState();
        
        if (stock.length === 0) {
            stock = discard.reverse().map(c => { c.faceUp = false; return c; });
            discard = [];
        } else {
            let card = stock.pop();
            card.faceUp = true;
            discard.push(card);
        }
        if(!isSolving) render();
    }

    // --- Drag & Drop ---
    let dragItem = null, dragClone = null, startX, startY;

    function attachDragListeners(el) {
        el.addEventListener('touchstart', handleTouchStart, {passive: false});
        el.addEventListener('touchmove', handleTouchMove, {passive: false});
        el.addEventListener('touchend', handleTouchEnd);
        el.addEventListener('mousedown', handleMouseDown);
    }

    function handleTouchStart(e) {
        if(e.touches.length > 1) return;
        e.preventDefault();
        startDrag(e.target.closest('.card'), e.touches[0].clientX, e.touches[0].clientY);
    }
    function handleMouseDown(e) {
        e.preventDefault();
        startDrag(e.target.closest('.card'), e.clientX, e.clientY);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
    }
    function startDrag(cardEl, clientX, clientY) {
        if (!cardEl || cardEl.classList.contains('back')) return;
        dragItem = cardEl;
        startX = clientX;
        startY = clientY;
        const rect = dragItem.getBoundingClientRect();
        
        dragClone = dragItem.cloneNode(true);
        dragClone.classList.add('dragging');
        dragClone.style.position = 'fixed';
        dragClone.style.left = rect.left + 'px';
        dragClone.style.top = rect.top + 'px';
        dragClone.style.width = rect.width + 'px';
        dragClone.style.height = rect.height + 'px';
        document.body.appendChild(dragClone);
        dragItem.classList.add('placeholder');
    }
    function handleTouchMove(e) { if (!dragClone) return; e.preventDefault(); moveDrag(e.touches[0].clientX, e.touches[0].clientY); }
    function handleMouseMove(e) { if (!dragClone) return; moveDrag(e.clientX, e.clientY); }
    function moveDrag(clientX, clientY) {
        const dx = clientX - startX; const dy = clientY - startY;
        dragClone.style.transform = `translate(${dx}px, ${dy}px)`;
    }
    function handleTouchEnd(e) { if (!dragClone) return; const touch = e.changedTouches[0]; endDrag(touch.clientX, touch.clientY); }
    function handleMouseUp(e) { if (!dragClone) return; document.removeEventListener('mousemove', handleMouseMove); document.removeEventListener('mouseup', handleMouseUp); endDrag(e.clientX, e.clientY); }

    function endDrag(clientX, clientY) {
        if(dragClone) dragClone.remove(); 
        if(dragItem) {
            dragItem.classList.remove('placeholder');
            dragItem.style.display = 'none'; 
            let elemBelow = document.elementFromPoint(clientX, clientY);
            dragItem.style.display = 'flex';
            
            if (elemBelow) {
                let dropTarget = elemBelow.closest('.card, .tableau-col, .foundation');
                if (dropTarget) processMove(dragItem, dropTarget);
            }
        }
        dragItem = null; dragClone = null;
    }

    function processMove(cardEl, targetEl) {
        const sSource = cardEl.dataset.source;
        const sCol = parseInt(cardEl.dataset.col);
        const sIdx = parseInt(cardEl.dataset.idx);

        let tType, tCol;
        if (targetEl.classList.contains('foundation')) { tType = 'foundation'; tCol = parseInt(targetEl.dataset.index); } 
        else if (targetEl.classList.contains('tableau-col')) { tType = 'tableau'; tCol = parseInt(targetEl.dataset.index); } 
        else if (targetEl.classList.contains('card')) { tType = targetEl.dataset.source; tCol = parseInt(targetEl.dataset.col); }

        if (!tType) return;
        
        let movingCards = [];
        if (sSource === 'tableau') movingCards = tableau[sCol].slice(sIdx);
        else if (sSource === 'discard') movingCards = [discard[discard.length-1]];
        else if (sSource === 'foundation') movingCards = [foundations[sCol][foundations[sCol].length-1]];

        const bottomMoving = movingCards[0];
        let allowed = false;

        if (tType === 'foundation') {
            if (movingCards.length === 1) {
                const pile = foundations[tCol];
                const topRank = pile.length;
                if (bottomMoving.suit === suits[tCol] && bottomMoving.rank === topRank + 1) allowed = true;
            }
        }
        else if (tType === 'tableau') {
            const destCol = tableau[tCol];
            const destCard = destCol.length > 0 ? destCol[destCol.length - 1] : null;
            if (!destCard) {
                if (bottomMoving.rank === 13) allowed = true;
            } else {
                const destColor = colors[destCard.suit];
                const moveColor = colors[bottomMoving.suit];
                if (destColor !== moveColor && destCard.rank === bottomMoving.rank + 1) allowed = true;
            }
        }

        if (allowed) {
            saveState();
            if (sSource === 'tableau') tableau[sCol].splice(sIdx);
            else if (sSource === 'discard') discard.pop();
            else if (sSource === 'foundation') foundations[sCol].pop();

            if (tType === 'tableau') tableau[tCol].push(...movingCards);
            else if (tType === 'foundation') foundations[tCol].push(movingCards[0]);

            updateScore(10);
            render();
        }
    }

    function updateScore(n) {
        score += n;
        document.getElementById('score').innerText = 'Score: ' + score;
    }
    
    function checkWin() {
        if (foundations.every(f => f.length === 13)) {
            document.getElementById('win-message').style.display = 'block';
            enableControls(true);
        }
    }

    // Start
    let firstDeck = createDeck();
    shuffle(firstDeck);
    initialDeckState = JSON.parse(JSON.stringify(firstDeck));
    startGame(firstDeck);
</script>
</body>
</html>
